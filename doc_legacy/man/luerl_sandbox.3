.\" Automatically generated by Pandoc 3.6
.\"
.TH "luerl_sandbox" "3" "2023" ""
.SH Name
luerl_sandbox \- Fuctions for sandboxing Luerl evaluation
.SH Interface Functions
The \f[B]Lua State\f[R] parameter is the state of a Lua VM instance.
It must be created with the \f[B]luerl:init()\f[R] call and be carried
from one call to the next.
.PP
As it is possible in Lua to create self\-referencing data structures,
indeed the standard libraries have many instances of this, then using
the functions which decode their return values will generate an error
when they would cause an infinite loop during the decoding.
An simple example is the top level table which contains a key
\f[B]\f[CB]_G\f[B]\f[R] which references the top\-level table.
.PP
Note that Lua \f[B]Chunks\f[R] (see definition below) can travel between
different States.
They are precompiled bits of code, independent of State.
That you can `carry around' this is no unique to Luerl but a low\-level
implementation detail of the standard Lua \c
.UR https://lua.org
language
.UE \c
, for more on chunks \c
.UR https://www.lua.org/manual/5.3/manual.html#3.3.2
read
.UE \c
\ the official Lua 5.3 \c
.UR https://www.lua.org/manual/5.3/manual.html
reference manual
.UE \c
\&.
.SS Spec Definitions
\f[B]Binary\f[R] means an Erlang binary string.
.PD 0
.P
.PD
\f[B]Chunks\f[R] means a portion of precompiled bytecode.
.PD 0
.P
.PD
\f[B]State\f[R] means a Lua State, this \f[I]is\f[R] a Lua VM instance.
.PD 0
.P
.PD
\f[B]Path\f[R] means a file system path and file name.
.PD 0
.P
.PD
\f[B]KeyPath\f[R] means an Erlang list of \f[B]atoms\f[R] representing
nested names, e.g.\ [table,pack] for table.pack.
.PD 0
.P
.PD
\f[B]Keys\f[R] means Lua table keys, the keys of a key\-value structure.
.SS Functions
.SS \f[B]\f[CB]init() \-> State.\f[B]\f[R]
.SS \f[B]\f[CB]init([ State | TablePaths]) \-> State.\f[B]\f[R]
.SS \f[B]\f[CB]init(State, TablePaths) \-> State.\f[B]\f[R]
Create a new sandboxed state.
If a state is given as an argument then that state will be used
otherwise a new default be be generated.
\f[CR]TablePaths\f[R] is a list of paths to functions which will be
blocked.
If none is given then the default list will be used.
.SS \f[B]\f[CB]run(String | Binary) \-> {Result, State} | {error, Reason}.\f[B]\f[R]
.SS \f[B]\f[CB]run(String | Binary, State) \-> {Result, State} | {error, Reason}.\f[B]\f[R]
.SS \f[B]\f[CB]run(String | Binary, Flags, State) \-> {Result, State} | {error, Reason}.\f[B]\f[R]
Spawn a new process which runs the string \f[CR]String\f[R] in
\f[CR]State\f[R] where the default sandbox state will be used if none is
given.
\f[CR]Flags\f[R] is a map or keyword list which can contain the
following fields
.IP
.EX
#{max_time => MaxTime,
  max_reductions => MaxReds,
  spawn_opts => SpawnOpts}
.EE
.PP
\f[CR]MaxReds\f[R] limits the number of reductions and
\f[CR]MaxTime\f[R] (default 100 msecs) the time to run the string,
\f[CR]SpawnOpts\f[R] are spawn options to the process running the
evaluation.
.SS \f[B]\f[CB]run(String | Binary) \-> {Result, State} | {error, Reason}.\f[B]\f[R]
.SS \f[B]\f[CB]run(String | Binary, State) \-> {Result, State} | {error, Reason}.\f[B]\f[R]
.SS \f[B]\f[CB]run(String | Binary, State, [ MaxReds | Flags ]) \-> {Result, State} | {error, Reason}.\f[B]\f[R]
.SS \f[B]\f[CB]run(String | Binary, State, MaxReds, Flags) \-> {Result, State} | {error, Reason}.\f[B]\f[R]
.SS \f[B]\f[CB]run(String | Binary, State, MaxReds, Flags, Timeout) \-> {Result, State} | {error, Reason}.\f[B]\f[R]
This is the old interface to run.
It still works but the new interface is recommended.
Spawn a new process which runs the string \f[CR]String\f[R] in
\f[CR]State\f[R] where the default sandbox state will be used if none is
given.
\f[CR]MaxReds\f[R] limits the number of reductions and
\f[CR]TimeOut\f[R] (default 100 msecs) the time to run the string,
\f[CR]Flags\f[R] are spawn options to the process running the
evaluation.
.SH AUTHORS
Robert Virding.
