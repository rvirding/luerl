.\" Automatically generated by Pandoc 3.6
.\"
.TH "luerl" "3" "2018\-2024" ""
.SH Name
luerl \- The basic interface to the Luerl system
.SH Interface functions \- New Version
The \f[B]Lua State\f[R] parameter is the state of a Lua VM instance.
It must be created with the \f[B]luerl:init()\f[R] call and be carried
from one call to the next.
.PP
As it is possible in Lua to create self\-referencing data structures,
indeed the standard libraries have many instances of this, then using
the functions which decode their return values will generate an error
when they would cause an infinite loop during the decoding.
An simple example is the top level table which contains a key
\f[B]\f[CB]_G\f[B]\f[R] which references the top\-level table.
.PP
Note that Lua \f[B]Chunks\f[R] (see definition below) can travel between
different States.
They are precompiled bits of code, independent of State.
That you can `carry around' this is no unique to Luerl but a low\-level
implementation detail of the standard Lua \c
.UR https://lua.org
language
.UE \c
, for more on chunks \c
.UR https://www.lua.org/manual/5.3/manual.html#3.3.2
read
.UE \c
\ the official Lua 5.3 \c
.UR https://www.lua.org/manual/5.3/manual.html
reference manual
.UE \c
\&.
.SS Spec Definitions
\f[B]Binary\f[R] means an Erlang binary string.
.PD 0
.P
.PD
\f[B]Chunks\f[R] means a portion of precompiled bytecode.
.PD 0
.P
.PD
\f[B]State\f[R] means a Lua State, this \f[I]is\f[R] a Lua VM instance.
.PD 0
.P
.PD
\f[B]Path\f[R] means a file system path and file name.
.PD 0
.P
.PD
\f[B]KeyPath\f[R] means an Erlang list of \f[B]atoms\f[R] representing
nested names, e.g.\ [table,pack] for table.pack.
.PD 0
.P
.PD
\f[B]Keys\f[R] means Lua table keys, the keys of a key\-value structure.
.PP
\f[B]CompileOptions\f[R] means a list of compiler options.
Currently supported options are `return', which returns the errors and
warnings, and `report' which will log the errors and warnings.
.PP
\f[B]LuaCallReturn = {ok, Result, State} | {lua_error, Error,
State}\f[R]
.PD 0
.P
.PD
This is the return value from evaluating a Lua call.
.SS Functions
.SS luerl:init() \-> State
Get a new Lua State = a fresh Lua VM instance.
.SS luerl:gc(State) \-> State
Runs the garbage collector on a state and returns the new state.
.SS luerl:load(String|Binary[, CompileOptions], State) \-> {ok, Function, State} | CompileError
Parse a Lua chunk as string or binary, and return a compiled chunk
(`form').
.SS luerl:loadfile(FileName[, CompileOptions], State) \-> {ok, Function, State} | CompileError
Parse a Lua file, and return a compiled chunk (`form').
.SS luerl:path_loadfile([Path, ], FileName[, CompileOptions], State) \-> {ok,Function,FullName,State} | {error, Reason}
Search Path until the file FileName is found.
Parse the file and return a compiled chunk (`form').
If Path is not given then the path defined in the environment variable
LUA_LOAD_PATH is used.
.SS luerl:load_module(KeyPath, ErlangModule, State) \-> State
Load \f[CR]ErlangModule\f[R] and install its table at \f[CR]KeyPath\f[R]
which is \f[B]NOT\f[R] encoded.
.SS luerl:load_module_dec(EncodedKeyPath, ErlangModule, State) \-> State
Load \f[CR]ErlangModule\f[R] and install its table at \f[CR]KeyPath\f[R]
which is encoded.
.SS luerl:do(String|Binary|Form, State) \-> {ok, Result, NewState} | {lua_error, Error, State} | CompileError
Evaluate a Lua expression and return its result which is \f[B]NOT\f[R]
decoded, and the new Lua State.
.SS luerl:do_dec(String|Binary|Form, State) \-> {ok, Result, NewState} | {lua_error, Error, State} | CompileError
Evaluate a Lua expression and return its result which is automatically
decoded, and the new Lua State.
.SS luerl:dofile(Path, State) \-> {ok, Result, NewState} | {lua_error, Error, State} | CompileError
Load and execute the Lua code in the file and return its result which is
\f[B]NOT\f[R] decoded, and the new Lua State.
Equivalent to doing luerl:do(\[lq]return dofile(`FileName')\[rq]).
.SS luerl:dofile_dec(Path[, State]) \-> {ok, Result, NewState} | {lua_error, Error, State} | CompileError
Load and execute the Lua code in the file and return its result which is
automatically decoded, and the new Lua State.
.SS luerl:call(FuncRef, ArgRefs, State) \-> {ok, Result, State}
.SS luerl:call_chunk(FuncRef, ArgRefs, State) \-> {ok, Result, State} | {lua_error, Error, State}
Call a compiled chunk or function.
Use the call_chunk, call has been kept for backwards compatibility.
.SS luerl:call_function(FuncRef | FuncPath, ArgRefs, State] \-> {ok, Result, State} | {lua_error, Error, State}
Call a function already defined in the state.
\f[CR]Result\f[R] is \f[B]NOT\f[R] decoded.
.SS luerl:call_function_dec(KeyPath, Args, State) \-> {ok, Result, State} | {lua_error, Error, State}
Call a function already defined in the state.
\f[CR]KeyPath\f[R] is a list of keys to the function.
\f[CR]KeyPath\f[R], \f[CR]Args\f[R] and \f[CR]Result\f[R] are
automatically encoded/decoded.
.SS luerl:call_method(ObjRef, Method, ArgRefs, State) \-> {ok, Result, State} | {lua_error, Error, State}
Call a method already defined in the state.
.SS luerl:call_method_dec(KeyPath, Method, Args, State) \-> {ok, Result, State} | {lua_error, Error, State}
Call a method already defined in the state.
\f[CR]KeyPath\f[R] is a list of keys to the method.
\f[CR]KeyPath\f[R], \f[CR]Method\f[R], \f[CR]Args\f[R] and
\f[CR]Result\f[R] are automatically encoded/decoded.
.SS luerl:get_table_keys(KeyPath, State) \-> {ok, Result, State} | {lua_error, Error, State}
Gets a value inside the Lua state.
\f[CR]KeyPath\f[R] and \f[CR]Result\f[R] are \f[B]NOT\f[R]
encoded/decoded.
.SS luerl:get_table_keys_dec(KeyPath, State) \-> {ok, Result, State} | {lua_error, Error, State}
Gets a value inside the Lua state.
\f[CR]KeyPath\f[R] is automatically encoded and \f[CR]Result\f[R] is
decoded.
.SS luerl:set_table_keys(KeyPath, Value, State) \-> {ok,State} | {lua_error, Error, State}
Sets a value inside the Lua state.
\f[CR]KeyPath\f[R] and \f[CR]Value\f[R] are \f[B]NOT\f[R] encoded.
.SS luerl:set_table_keys_dec(KeyPath, Value, State) \-> {ok, Result, State} | {lua_error, Error, State}
Sets a value inside the Lua state.
\f[CR]KeyPath\f[R] and \f[CR]Value\f[R] are automatically encoded and
\f[CR]Result\f[R] is decoded.
.SS luerl:get_table_key(Table, Key, State) \-> {ok, Result, State} | {lua_error, Error, State}
Gets the value of a key in a table.
\f[CR]Table\f[R] and \f[CR]Key\f[R] are \f[B]NOT\f[R] encoded and
\f[CR]Result\f[R] is \f[B]NOT\f[R] decoded.
.SS luerl:set_table_key(Table, Key, Value, State) \-> {ok, State} | {lua_error, Error, State}
Sets the value of a key in a table.
\f[CR]Table\f[R], \f[CR]Key\f[R] and \f[CR]Value\f[R] are \f[B]NOT\f[R]
encoded.
.SS luerl:get_stacktrace(State) \-> [{FuncName,{file,FileName},{line,Line}}]
Return a stack trace of the current call stack in the state.
.SS luerl:encode(Term, State) \-> {LuerlTerm,State}
Encode the Erlang representation of a term into Luerl form updating the
state when necessary.
.SS luerl:encode_list([Term], State) \-> {[LuerlTerm],State}
Encode a list of Erlang term representations into a list of Luerl forms
updating the state when necessary.
.SS luerl:decode(LuerlTerm, State) \-> Term
Decode a term in the Luerl form into its Erlang representation.
.SS luerl:decode_list([LuerlTerm], State) \-> [Term]
Decode a list of Luerl terms into a list of Erlang representations.
.SS luerl:put_private(Key, Term, State) \-> State.
Puts a private value under key that is not exposed to the runtime.
.SS luerl:get_private(Key, State) \-> Term.
Get a private value for the given key.
.SS luerl:delete_private(Key, State) \-> Term.
Deletes the private value for the given key.
.SS Passing String in the Erlang Shell
Here we are going to look at passing in command strings into the
\f[CR]luerl:do/2\f[R] function, especially when these strings contain
Lua strings.
The problem is to make sure that the strings in the Lua commands are
processes correctly.
.PP
First just just doing it from the standard Lua shell as the source of
truth:
.IP
.EX
>return \[dq]aéb\[rs]235c\[dq]
aéb?c
>string.byte(\[dq]aéb\[rs]235c\[dq], 1, 20)
97    195    169    98    235    99
.EE
.PP
Now doing it from Erlang where I need to use \[rs]\[rs] to get a \[rs]
into the string:
.IP
.EX
1> St = luerl:init(), ok.
ok
2> f(S), S = \[dq]return \[aq]aéb\[rs]\[rs]235c\[aq]\[dq].
[114,101,116,117,114,110,32,39,97,233,98,92,50,51,53,99,39]
3> f(R), {ok,R,_} = luerl:do(S, St), io:write(R).
[<<97,195,169,98,235,99>>]
.EE
.PP
Now doing it from Elixir using the \f[CR]\[ti]C\f[R] sigil to get the
handling of the string right:
.IP
.EX
iex(1)> st = Luerl.init(); :ok
:ok
iex(4)> s = \[ti]C\[dq]return \[aq]aéb\[rs]235c\[aq]\[dq]
[114,101,116,117,114,110,32,39,97,233,98,92,50,51,53,99,39]
iex(3)> {ok,r,_} = Luerl.do(st, s); r
[<<97, 195, 169, 98, 235, 99>>]
.EE
.PP
So it works as expected.
We use \f[CR]io:write\f[R] to write out the characters in the binary
without any parsing or trying to be smart.
.SH AUTHORS
Jean Chassoul, Robert Virding.
