{
    "docs": [
        {
            "location": "/Data-representation/", 
            "text": "Luerl represents data in two ways, an internal and external formats. The external format is designed to interface as nice as possible with native Erlang while the internal format represents data as it is handled inside this implementation of the Lua 5.2 VM and interpreter.\n\n\nThe \nluerl\n module has two groups of functions, those ending in '1' and those that don't. Those that don't assume that the arguments are in external format and automatically encodes them, while those ending in '1' assume they are in internal format.\n\n\nIn most cases using the external format makes code more readable and understandable. However saving the translation costs by directly manipulating data in the internal format can be worth it, once a function for the internal representation is used you are hooked and there is no going back! \n\n\nTo illustrate the following two code examples are identical the first using the external representation the second using the internal one:\n\n\nSt0 = luerl:init().\nF = fun(_, StIn) -\n\n    {[[{\na\n, 1.0}]], StIn}\n  end.\nSt1 = luerl:set_table([t], F, St0).\nluerl:eval(\nreturn t()\n, St1).\n\n\n\n\nS0 = luerl:init().\nF = fun ([], Sti) -\n\n    {T, Sto} = luerl_emul:alloc_table([{\na\n, 1.0}], Sti),\n    {[T], Sto}\n  end.\nS1 = luerl:set_table1([\nt\n], {function, F}, S0).\nluerl:eval(\nreturn t()\n, S1). \n\n\n\n\nData types\n\n\nFor the Lua data types we internally use their corresponding Erlang type:\n\n\nnil        - atom nil\n\n\ntrue/false - atoms true/false\n\n\nstrings    - string binaries\n\n\nnumbers    - floats\n\n\ntables     - #table{} with array for keys 1..n, ordict for rest\n\n\nfunctions  - #function{} or {function,Fun}\n\n\nSee \nluerl.hrl\n for the field names of the records.\n\n\nAll tables are combinations of Erlang ttdicts and arrays. In each table an\narray is used for integer keys \n= 1 while an ttdict is used for all other keys.\n\n\nWe use this information when building/processing tables.\n\n\nNil\n\n\nNil is a type represented by the Erlang atom \nnil\n, whose main property is to be different from any other value. Lua uses nil as a kind of non-value, to represent the absence of a useful value.\n\n\nBooleans\n\n\nErlang atoms \ntrue\n and \nfalse\n.\n\n\nStrings\n\n\nStrings are represented the same in both formats, luerl uses binary strings list strings will be interpreted as a table!\n\n\nNumbers\n\n\nNumbers are the same in both internal and external representations, they are simple float numbers. Please be aware that in Lua \n= 5.2 numbers are treated as floats.\n\n\nTables\n\n\nTables in Lua are known as associative arrays. All Lua types can be used as keys, except \nnil\n.\n\n\nTables are the only data structure mechanism in Lua, tables implement many data types in simple and efficient ways, lists, sets, arrays, sparse matrices, structures, the kitchen sink, you name it. Tables in Lua are also used for several other purposes like global variables, modules, object and classes, next are some notes about the insides of its Luerl implementation.\n\n\nIn the external format tables are represented as lists of tuples, where the first element is the index and the second the value or as lists of values where the index is implicitly assigned by their position in the list (starting with 1). The tables \n[1]\n and \n[{1,1}]\n are identical.\n\n\nIn the internal format tables are represented as references, to allocate a table reference the function \nluerl_emul:alloc_table/2\n is that returns a new reference and a state that includes this reference then given a name using \nluerl:set_table1/3\n. Single keys can be accessed using \nluerl:get_table1/2\n to resolve a name to a reference and then \nluerl_emul:get_table_keys/3\n to get the value for a given key in the table.\n\n\nFunctions\n\n\nIn the external representations functions are simply functions of the arity/2, where the first argument is a list of function arguments and the state at the time of function execution.\n\n\nThey return a tuple with a list of return values as the first argument and the new state. \n\n\nAll parameters are in the external format and all return values need to be in the external format.\n\n\nIn the internal format functions are a tuple with the first element being the atom \nfunction\n and the second a function of the arity/2.\n\n\nBoth the return values as well as the function parameters are in the internal format as well.", 
            "title": "Data representation"
        }, 
        {
            "location": "/Data-representation/#data-types", 
            "text": "For the Lua data types we internally use their corresponding Erlang type:  nil        - atom nil  true/false - atoms true/false  strings    - string binaries  numbers    - floats  tables     - #table{} with array for keys 1..n, ordict for rest  functions  - #function{} or {function,Fun}  See  luerl.hrl  for the field names of the records.  All tables are combinations of Erlang ttdicts and arrays. In each table an\narray is used for integer keys  = 1 while an ttdict is used for all other keys.  We use this information when building/processing tables.", 
            "title": "Data types"
        }, 
        {
            "location": "/Data-representation/#nil", 
            "text": "Nil is a type represented by the Erlang atom  nil , whose main property is to be different from any other value. Lua uses nil as a kind of non-value, to represent the absence of a useful value.", 
            "title": "Nil"
        }, 
        {
            "location": "/Data-representation/#booleans", 
            "text": "Erlang atoms  true  and  false .", 
            "title": "Booleans"
        }, 
        {
            "location": "/Data-representation/#strings", 
            "text": "Strings are represented the same in both formats, luerl uses binary strings list strings will be interpreted as a table!", 
            "title": "Strings"
        }, 
        {
            "location": "/Data-representation/#numbers", 
            "text": "Numbers are the same in both internal and external representations, they are simple float numbers. Please be aware that in Lua  = 5.2 numbers are treated as floats.", 
            "title": "Numbers"
        }, 
        {
            "location": "/Data-representation/#tables", 
            "text": "Tables in Lua are known as associative arrays. All Lua types can be used as keys, except  nil .  Tables are the only data structure mechanism in Lua, tables implement many data types in simple and efficient ways, lists, sets, arrays, sparse matrices, structures, the kitchen sink, you name it. Tables in Lua are also used for several other purposes like global variables, modules, object and classes, next are some notes about the insides of its Luerl implementation.  In the external format tables are represented as lists of tuples, where the first element is the index and the second the value or as lists of values where the index is implicitly assigned by their position in the list (starting with 1). The tables  [1]  and  [{1,1}]  are identical.  In the internal format tables are represented as references, to allocate a table reference the function  luerl_emul:alloc_table/2  is that returns a new reference and a state that includes this reference then given a name using  luerl:set_table1/3 . Single keys can be accessed using  luerl:get_table1/2  to resolve a name to a reference and then  luerl_emul:get_table_keys/3  to get the value for a given key in the table.", 
            "title": "Tables"
        }, 
        {
            "location": "/Data-representation/#functions", 
            "text": "In the external representations functions are simply functions of the arity/2, where the first argument is a list of function arguments and the state at the time of function execution.  They return a tuple with a list of return values as the first argument and the new state.   All parameters are in the external format and all return values need to be in the external format.  In the internal format functions are a tuple with the first element being the atom  function  and the second a function of the arity/2.  Both the return values as well as the function parameters are in the internal format as well.", 
            "title": "Functions"
        }, 
        {
            "location": "/Getting-started/", 
            "text": "Lua\n is implemented in \nLuerl\n as a library to start using it you need to include luerl as dependency on your OTP application.\n\n\nFor this tutorial we're going to use \nerlang.mk\n to setup quickly our environment, build our code and start or stop the project release.\n\n\nErlang.mk is very easy to setup: create a folder, put Erlang.mk in it, and write a Makefile:\n\n\ninclude erlang.mk\n\n\nFor a step by step:\n\n\n$ mkdir luerl_demo\n\n\n$ cd luerl_demo\n\n\n$ curl https://erlang.mk/erlang.mk -o erlang.mk\n\n\nCreate a Makefile and copy the next code snippet, there you can make the correct changes to reflect your project needs.\n\n\nPROJECT = ophelia\nDEPS = luerl\ninclude erlang.mk\n\n\n\n\n$ make\n\n\nFrom that point you can create an src/ folder or start using http://erlang.mk/ templates - \nUser guide\n.\n\n\nHello world\n\n\n$ git clone https://github.com/nonsensews/luerl_demo.git\n\n\n$ cd luerl_demo\n\n\n$ curl https://erlang.mk/erlang.mk -o erlang.mk\n\n\n$ make\n\n\n$ ./hello.sh\n\n\nShow me the ships!\n\n\nYou first need to get \nsdl2\n and \nsdl_image\n installed on your machine then you'll be all set.\n\n\n$ cd ships\n\n\n$ ./demo.sh", 
            "title": "Getting started"
        }, 
        {
            "location": "/Getting-started/#hello-world", 
            "text": "$ git clone https://github.com/nonsensews/luerl_demo.git  $ cd luerl_demo  $ curl https://erlang.mk/erlang.mk -o erlang.mk  $ make  $ ./hello.sh", 
            "title": "Hello world"
        }, 
        {
            "location": "/Getting-started/#show-me-the-ships", 
            "text": "You first need to get  sdl2  and  sdl_image  installed on your machine then you'll be all set.  $ cd ships  $ ./demo.sh", 
            "title": "Show me the ships!"
        }, 
        {
            "location": "/Hello-Erlang/", 
            "text": "The Lua interpreter runs entirely inside its own Lua VM implemented in Erlang/OTP, however by itself has no access to any Erlang functions or modules.\n\n\nThis means that the only way to extend the reach of a Lua script is by filling the tables in the interpreter state with Lua functions that can reach over that boundary.\n\n\nOn the most basic level the standard libraries (\nluerl_lib_...\n) provide some of those functions. When \nluerl:init()\n is run to create a new lua-state those libraries get loaded and their functions added to the related tables, \nluerl_lib_io\n is loaded to \nio\n and so on.\n\n\nThat is a good start for basic programs but in the case we use \nluerl\n to extend our own program with scripting capabilities we need more. Adding our own functions (that call our own Erlang logic) can be done by using \nluerl:set_table/3\n with a function as the second argument.\n\n\nFunctions\n\n\nA few words should be said about how functions are handled in Luerl. Here a Lua function maps to an Erlang function with two arguments:\n\n\n\n\nthe list of arguments passed to the Lua function\n\n\nthe current state of the Lua interpreter\n\n\n\n\nIt then does it's work and return a tuple of two arguments:\n\n\n\n\na list of return values\n\n\nthe new state of the Lua interpreter\n\n\n\n\nSo the call:\n\n\nadd(1, 2) # =\n 3\n\n\n\n\nwould look like this for the Erlang code interpreting it:\n\n\nadd([1, 2], St) -\n\n  {[1 + 2], St}\n\n\n\n\nreturn values\n\n\nWe can return a few value types from a function (as each element of the return list):\n\n\n\n\na number (will always be treated as a float)\n\n\na (binary) string\n\n\na table, which is represented as a list of tuples where the first argument is a key and the second is the value.\n\n\na list (which will then be translated into a table with integer indexes)\n\n\na function (of arity/2)\n\n\n\n\nExamples\n\n\nAdd function\n\n\nA very trivial example would be a add function:\n\n\n%% Initiate an empty state.\nSt0 = luerl:init().\n%% Put the add function in the main table of the state (and get a new one)\nSt1 = luerl:set_table([add], fun([A, B], St) -\n {[A + B], St} end, St0).\n%% evaluate a little example script.\nluerl:eval(\nreturn add(1, 1)\n, St1).\n\n\n\n\nA more complex example would be creating a process that counts things (yes that can also be done with variables but let's ignore that part). We implement a function called \ncounter\n that will spawn a new erlang process that waits for messages. Then we return a table with 3 functions (\nadd\n, \nsub\n, and \nget\n) that act as closures around the processes PID. We now have a lua table that can uses \nsend\n, \nreceive\n and \nspawn\n all functions that usually can't be accessed from \nluerl\n directly.\n\n\nCounter process\n\n\n%% Our loop function for the process\nLoop = fun(N, L) -\n\n         receive\n           {get, Pid, Ref} -\n\n             Pid ! {count, Ref, N},\n             L(N, L);\n           {add, X} -\n\n             L(N + X, L);\n           {sub, X} -\n\n             L(N - X, L)\n          end\n        end.\n%% The initial state.\nSt0 = luerl:init().\n%% We add the counter function that returns a table\nSt1 = luerl:set_table([counter], fun([Initial], St) -\n \n  %% Spawn a process with the loop function (defined above).\n  Pid = spawn(fun() -\n Loop(Initial, Loop) end),\n  %% Create a table (a list of tuples) to return\n  %% those anonymous functions use Pid which is defined in\n  %% the current scope but won't be visible outside or to lua.\n  R = [{add, fun([N], StF) -\n Pid ! {add, N}, {[N], StF} end},\n       {sub, fun([N], StF) -\n Pid ! {sub, N}, {[N], StF} end},\n       {get, fun([], StF) -\n \n               Ref = erlang:make_ref(),\n               Pid ! {get, self(), Ref},\n               receive\n                 {count, Ref, N} -\n\n                   {[N], StF}\n               after\n                 10000 -\n\n                   {[timeout], StF}\n               end\n             end}],\n     %% return the table we just created\n     {[R], St}\n   end, St0).\n%% We call a little script now it will:\n%% 1) create a new counter\n%% 2) print the initial state\n%% 3) add 1 to the counter\n%% 4) print the changed state\nluerl:eval(\nc = counter(0); print(\\\n0: \\\n, c.get()); c.add(1); print(\\\n1: \\\n, c.get())\n, St1).\n%% The output will be:\n%%   1: 0\n%%   2: 1", 
            "title": "Hello Erlang"
        }, 
        {
            "location": "/Hello-Erlang/#functions", 
            "text": "A few words should be said about how functions are handled in Luerl. Here a Lua function maps to an Erlang function with two arguments:   the list of arguments passed to the Lua function  the current state of the Lua interpreter   It then does it's work and return a tuple of two arguments:   a list of return values  the new state of the Lua interpreter   So the call:  add(1, 2) # =  3  would look like this for the Erlang code interpreting it:  add([1, 2], St) - \n  {[1 + 2], St}", 
            "title": "Functions"
        }, 
        {
            "location": "/Hello-Erlang/#return-values", 
            "text": "We can return a few value types from a function (as each element of the return list):   a number (will always be treated as a float)  a (binary) string  a table, which is represented as a list of tuples where the first argument is a key and the second is the value.  a list (which will then be translated into a table with integer indexes)  a function (of arity/2)", 
            "title": "return values"
        }, 
        {
            "location": "/Hello-Erlang/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/Hello-Erlang/#add-function", 
            "text": "A very trivial example would be a add function:  %% Initiate an empty state.\nSt0 = luerl:init().\n%% Put the add function in the main table of the state (and get a new one)\nSt1 = luerl:set_table([add], fun([A, B], St) -  {[A + B], St} end, St0).\n%% evaluate a little example script.\nluerl:eval( return add(1, 1) , St1).  A more complex example would be creating a process that counts things (yes that can also be done with variables but let's ignore that part). We implement a function called  counter  that will spawn a new erlang process that waits for messages. Then we return a table with 3 functions ( add ,  sub , and  get ) that act as closures around the processes PID. We now have a lua table that can uses  send ,  receive  and  spawn  all functions that usually can't be accessed from  luerl  directly.", 
            "title": "Add function"
        }, 
        {
            "location": "/Hello-Erlang/#counter-process", 
            "text": "%% Our loop function for the process\nLoop = fun(N, L) - \n         receive\n           {get, Pid, Ref} - \n             Pid ! {count, Ref, N},\n             L(N, L);\n           {add, X} - \n             L(N + X, L);\n           {sub, X} - \n             L(N - X, L)\n          end\n        end.\n%% The initial state.\nSt0 = luerl:init().\n%% We add the counter function that returns a table\nSt1 = luerl:set_table([counter], fun([Initial], St) -  \n  %% Spawn a process with the loop function (defined above).\n  Pid = spawn(fun() -  Loop(Initial, Loop) end),\n  %% Create a table (a list of tuples) to return\n  %% those anonymous functions use Pid which is defined in\n  %% the current scope but won't be visible outside or to lua.\n  R = [{add, fun([N], StF) -  Pid ! {add, N}, {[N], StF} end},\n       {sub, fun([N], StF) -  Pid ! {sub, N}, {[N], StF} end},\n       {get, fun([], StF) -  \n               Ref = erlang:make_ref(),\n               Pid ! {get, self(), Ref},\n               receive\n                 {count, Ref, N} - \n                   {[N], StF}\n               after\n                 10000 - \n                   {[timeout], StF}\n               end\n             end}],\n     %% return the table we just created\n     {[R], St}\n   end, St0).\n%% We call a little script now it will:\n%% 1) create a new counter\n%% 2) print the initial state\n%% 3) add 1 to the counter\n%% 4) print the changed state\nluerl:eval( c = counter(0); print(\\ 0: \\ , c.get()); c.add(1); print(\\ 1: \\ , c.get()) , St1).\n%% The output will be:\n%%   1: 0\n%%   2: 1", 
            "title": "Counter process"
        }, 
        {
            "location": "/Hello-Lua/", 
            "text": "To do this you need to define an interface module written in Erlang with functions you call from the standard Lua 5.2 implemented by Luerl.\n\n\nThere is a predefined way of building and loading such a module so it can be reached from Lua through a table like any other Lua function. \n\n\nThere is also a predefined way of passing data in and out of these functions. If you look in the source code all the modules luerl_lib_XXXX.erl are interface modules like this. If you check in the module luerl_emul.erl in the function load_lib/3 you can see how it is installed.\n\n\nOne reason for having it this way is that it makes sandboxing very easy as Lua code cannot do this loading, it has to be done in the surrounding Erlang environment.\n\n\nLUA_PATH\n\n\n?\n\n\nSandboxing\n\n\nSometimes we want to do exactly the opposite, not add functionality to what the luerl interpreter can do but remove it. Since, as discussed above, the only way it can access functionality is if it is stored in one of the tables (that reside in the state) restricting functionality is as simple as removing some of the tables.\n\n\nIf we for example we really hate math and want to make sure no mathematical functions are ever called in scripts we run we could do the following:\n\n\nSt0 = luerl:init().\nSt1 = luerl:set_table([math], \nno math for you!\n, St0).\nluerl:eval(\nreturn math\n, St1).\n\n\n\n\nOf cause this also works with other tables, like \nio\n or \nfile\n which would prevent a lua script to access files or perform IO-operations (not as fun as forbidding math but in some cases still helpful).", 
            "title": "Hello Lua"
        }, 
        {
            "location": "/Hello-Lua/#lua_path", 
            "text": "?", 
            "title": "LUA_PATH"
        }, 
        {
            "location": "/Hello-Lua/#sandboxing", 
            "text": "Sometimes we want to do exactly the opposite, not add functionality to what the luerl interpreter can do but remove it. Since, as discussed above, the only way it can access functionality is if it is stored in one of the tables (that reside in the state) restricting functionality is as simple as removing some of the tables.  If we for example we really hate math and want to make sure no mathematical functions are ever called in scripts we run we could do the following:  St0 = luerl:init().\nSt1 = luerl:set_table([math],  no math for you! , St0).\nluerl:eval( return math , St1).  Of cause this also works with other tables, like  io  or  file  which would prevent a lua script to access files or perform IO-operations (not as fun as forbidding math but in some cases still helpful).", 
            "title": "Sandboxing"
        }, 
        {
            "location": "/Hello-examples/", 
            "text": "To run the examples, do \nmake\n and then start the Erlang command line with \nerl -pa ./ebin\n.\n\n\nDon't be shocked by the very long dump following each function call.\n \n\nAt the command line you are seeing the Lua State dumped, that is returned by these calls:\n\n\nexecute a string\n\n\nluerl:do(\"print(\\\"Hello, Robert!\\\")\").\n\n\n\nexecute a file\n\n\nluerl:dofile(\"./examples/hello/hello.lua\").\n\n\n\nseparately parse, then execute\n\n\nEmptyState = luerl:init(),\n{ok, Chunk, State} = luerl:load(\"print(\\\"Hello, Chunk!\\\")\", EmptyState),\n{_Ret, _NewState} = luerl:do(Chunk, State).\n\n\n\ncall a function in the state\n\n\n{Res,State1} = luerl:call_function([table,pack], [\n\"a\"\n,\n\"b\"\n,42], State0)\n\n\n\nexecutes the call \ntable.pack(\"a\", \"b\", 42)\n in \nState0\n. E.g.:\n\n\n{Res,State1} = luerl:call([table,pack], [\n\"a\"\n,\n\"b\"\n,42]),\nio:format(\"~p~n\",[Res]).\n\n\n\ncall a method in the state\n\n\n{Res,State1} = luerl:call_method([g,h,i], [\n\"a\"\n,\n\"b\"\n,42], State0)\n\n\n\nexecutes the call \ng.h:i(\"a\", \"b\", 42)\n in \nState0\n.\n\n\ndefine a method in the state\n\n\nState1 = luerl:set_table([inc], fun([Val], State) -\n {[Val+1], State} end)\n\n\n\nthe method can be called like this:\n\n\nluerl:do(\n\"print(inc(4))\"\n, State1)\n\n\n\nExamples\n\n\nFor more information see the \nexamples\n directory:  \n\n\n./hello.erl\n is very brief while \nexamples/hello/hello2.erl\n offers a comprehensive list on how use the individual interface functions.\n\n\nYou can build and run these samples with:\n\n\nmake examples", 
            "title": "Hello examples"
        }, 
        {
            "location": "/Hello-examples/#execute-a-string", 
            "text": "luerl:do(\"print(\\\"Hello, Robert!\\\")\").", 
            "title": "execute a string"
        }, 
        {
            "location": "/Hello-examples/#execute-a-file", 
            "text": "luerl:dofile(\"./examples/hello/hello.lua\").", 
            "title": "execute a file"
        }, 
        {
            "location": "/Hello-examples/#separately-parse-then-execute", 
            "text": "EmptyState = luerl:init(),\n{ok, Chunk, State} = luerl:load(\"print(\\\"Hello, Chunk!\\\")\", EmptyState),\n{_Ret, _NewState} = luerl:do(Chunk, State).", 
            "title": "separately parse, then execute"
        }, 
        {
            "location": "/Hello-examples/#call-a-function-in-the-state", 
            "text": "{Res,State1} = luerl:call_function([table,pack], [ \"a\" , \"b\" ,42], State0)  executes the call  table.pack(\"a\", \"b\", 42)  in  State0 . E.g.:  {Res,State1} = luerl:call([table,pack], [ \"a\" , \"b\" ,42]),\nio:format(\"~p~n\",[Res]).", 
            "title": "call a function in the state"
        }, 
        {
            "location": "/Hello-examples/#call-a-method-in-the-state", 
            "text": "{Res,State1} = luerl:call_method([g,h,i], [ \"a\" , \"b\" ,42], State0)  executes the call  g.h:i(\"a\", \"b\", 42)  in  State0 .", 
            "title": "call a method in the state"
        }, 
        {
            "location": "/Hello-examples/#define-a-method-in-the-state", 
            "text": "State1 = luerl:set_table([inc], fun([Val], State) -  {[Val+1], State} end)  the method can be called like this:  luerl:do( \"print(inc(4))\" , State1)", 
            "title": "define a method in the state"
        }, 
        {
            "location": "/Hello-examples/#examples", 
            "text": "For more information see the  examples  directory:    ./hello.erl  is very brief while  examples/hello/hello2.erl  offers a comprehensive list on how use the individual interface functions.  You can build and run these samples with:  make examples", 
            "title": "Examples"
        }, 
        {
            "location": "/Home/", 
            "text": "Luerl\n is an implementation of standard Lua 5.2 written in Erlang/OTP.\n\n\nLua is a powerful, efficient, lightweight, embeddable scripting language common in games, IoT devices, AI bots, machine learning and scientific computing research.\n\n\nIt supports procedural, object-oriented, functional, data-driven, reactive, organizational programming and data description.\n\n\nBeing an extension language, Lua has no notion of a \"main\" program: it works as a library embedded in a host. The host program can invoke functions to execute a piece of Lua code, can write and read Lua variables, and call Erlang functions by Lua code.\n\n\nThrough the use of Erlang functions, Luerl can be augmented to cope with a wide range of different domains, creating a customized language sharing a syntactical framework. \n\n\nLuerl is a library, written in clean Erlang/OTP. For more information, click on the \nget started\n tutorial. You may also browse the \nexamples\n and learn from the \nluerl_demo\n source code.", 
            "title": "Home"
        }, 
        {
            "location": "/Installing-Luerl/", 
            "text": "Luerl\n implement standard \nLua\n 5.2 in pure Erlang to start using the project you need to include the luerl library as new dependency on your OTP application.\n\n\nHex\n\n\nYou can install \nluerl\n from \nhex.pm\n by including the following in your \nrebar.config\n:\n\n\n{deps,[\n    {luerl, \nX.Y.Z\n}\n]}.\n\n\n\n\nwhere \nX.Y.Z\n is one of the \nrelease versions\n.\n\n\nFor more info on rebar3 dependencies see the \nrebar3 docs\n.\n\n\nErlang.mk\n\n\nOr use \nerlang.mk\n to setup quickly your environment, build the code and project release.\n\n\nCreate a Makefile and include luerl to the project dependencies.\n\n\nDEPS = luerl\n\n\n\n\nSource code\n\n\n$ git clone https://github.com/rvirding/luerl.git", 
            "title": "Installing Luerl"
        }, 
        {
            "location": "/Installing-Luerl/#hex", 
            "text": "You can install  luerl  from  hex.pm  by including the following in your  rebar.config :  {deps,[\n    {luerl,  X.Y.Z }\n]}.  where  X.Y.Z  is one of the  release versions .  For more info on rebar3 dependencies see the  rebar3 docs .", 
            "title": "Hex"
        }, 
        {
            "location": "/Installing-Luerl/#erlangmk", 
            "text": "Or use  erlang.mk  to setup quickly your environment, build the code and project release.  Create a Makefile and include luerl to the project dependencies.  DEPS = luerl", 
            "title": "Erlang.mk"
        }, 
        {
            "location": "/Installing-Luerl/#source-code", 
            "text": "$ git clone https://github.com/rvirding/luerl.git", 
            "title": "Source code"
        }, 
        {
            "location": "/Interface-functions/", 
            "text": "All functions optionally accept a \nLua State\n parameter. The Lua State is the state of a Lua VM instance. It can be carried from one call to the next. If no State is passed in, a new state is initiated for the function call.\n\n\nAs it is possible in Lua to create self-referencing data structures, indeed the standard libraries have many instances of this, then using the functions which decode their return values can cause an infinite loop during the decoding. An simple example is the top level table which contains a key \n_G\n which references the top-level table.\n\n\nNote that Lua \nChunks\n (see definition below) can travel between different States. They are precompiled bits of code, independent of State. That you can 'carry around' this is no unique to Luerl but a low-level implementation detail of the standard Lua \nlanguage\n, for more on chunks \nread\n the official Lua 5.2 \nreference manual\n.\n\n\nSpec Definitions\n\n\nBinary\n means an Erlang binary string. \n\n\nChunks\n means a portion of precompiled bytecode. \n\n\nState\n means a Lua State, this \nis\n a Lua VM instance.      \n\n\nPath\n means a file system path and file name.\n\n\nKeyPath\n means an Erlang list of \natoms\n representing nested names, e.g. [table,pack] for table.pack.\n\n\nKeys\n means Lua table keys, the keys of a key-value structure.\n\n\nHello Examples\n\n\nSee below and files \nhello.erl\n and \nhello2.erl\n in \nexamples/hello/\n.\n\n\nFunctions\n\n\neval\n and \ndo\n functions differ only in what they return. The \ndo\n functions return results and a new Lua State, the \neval\n functions return a tuple starting on 'ok' or 'error', then the result, or cause of error.\n\n\ndo --\n {Result, State}\n\neval --\n {ok, Result} | {error, Reason}\n\n\n\nluerl:eval(String|Binary|Form[, State]) -\n {ok, Result} | {error, Reason}.\n\n\nEvaluate a Lua expression passed in as a string or binary, and return its result.\n\n\nluerl:evalfile(Path[, State]) -\n {ok, Result} | {error, Reason}.\n\n\nLoad and execute a file, and return the result.\n\n\nluerl:do(String|Binary|Form[, State]) -\n {Result, NewState}.\n\n\nEvaluate a Lua expression and return its result, and the new Lua State.\n\n\nluerl:dofile(Path[, State]) -\n {Result, NewState}.\n\n\nLoad and execute the Lua code in the file and return its result, and the new Lua State. Equivalent to doing luerl:do(\"return dofile('FileName')\").\n\n\nluerl:load(String|Binary[, State]) -\n {ok,Function,NewState} | {error, Reason} .\n\n\nParse a Lua chunk as string or binary, and return a compiled chunk ('form').\n\n\nluerl:loadfile(FileName[, State]) -\n {ok,Function,NewState}.\n\n\nParse a Lua file, and return a compiled chunk ('form').\n\n\nluerl:path_loadfile([Path, ], FileName, State) -\n {ok,Function,FullName,State}.\n\n\nSearch Path until the file FileName is found. Parse the file and return a compiled chunk ('form'). If Path is not given then the path defined in the environment variable LUA_LOAD_PATH is used.\n\n\nluerl:load_module(KeyPath, ErlangModule, State) -\n State.\n\n\nLoad \nErlangModule\n and install its table at \nKeyPath\n.\n\n\nluerl:load_module1(KeyPath, ErlangModule, State) -\n State.\n\n\nLoad \nErlangModule\n and install its table at \nKeyPath\n.\n\n\nluerl:init() -\n State.\n\n\nGet a new Lua State = a fresh Lua VM instance.\n\n\nluerl:call(Form, Args[, State]) -\n {Result,State}\n\n\nluerl:call_chunk(Form, Args[, State]) -\n {Result,State}\n\n\nCall a compiled chunk or function. Use the call_chunk, call has been kept for backwards compatibility.\n\n\nluerl:call_function(KeyPath, Args[, State]) -\n {Result,NewState}\n\n\nCall a function already defined in the state. \nKeyPath\n is a list of names to the function. \nKeyPath\n, \nArgs\n and \nResult\n are automatically encode/decoded.\n\n\nluerl:call_function1(KeyPath, Args, State) -\n {Result,NewState}\n\n\nCall a function already defined in the state. \nKeyPath\n is a list of keys to the function. \nKeyPath\n, \nArgs\n and \nResult\n are \nNOT\n encode/decoded.\n\n\nluerl:call_method(MethPath, Args[, State]) -\n {Result,NewState}.\n\n\nCall a method already defined in the state. \nMethPath\n is a list of names to the method. \nMethPath\n, \nArgs\n and \nResult\n are automatically encode/decoded.\n\n\nluerl:call_method1(MethPath, Args, State) -\n {Result,NewState}\n\n\nCall a method already defined in the state. \nMethPath\n is a list of keys to the method. \nKeys\n, \nArgs\n and \nResult\n are \nNOT\n encode/decoded.\n\n\nluerl:stop(State) -\n GCedState.\n\n\nGarbage collects the state and (todo:) does away with it.\n\n\nluerl:gc(State) -\n State.\n\n\nRuns the (experimental) garbage collector on a state and returns the new state.\n\n\nluerl:set_table(Path, Value, State) -\n State.\n\n\nSets a value inside the Lua state. Value is automatically encoded.\n\n\nYou can use this function to expose an function to the Lua code by\n using this interface:\n   fun(Args, State) -\n {Results, State}\n Args and Results must be a list of Luerl compatible erlang values.", 
            "title": "Interface functions"
        }, 
        {
            "location": "/Interface-functions/#spec-definitions", 
            "text": "Binary  means an Erlang binary string.   Chunks  means a portion of precompiled bytecode.   State  means a Lua State, this  is  a Lua VM instance.        Path  means a file system path and file name.  KeyPath  means an Erlang list of  atoms  representing nested names, e.g. [table,pack] for table.pack.  Keys  means Lua table keys, the keys of a key-value structure.", 
            "title": "Spec Definitions"
        }, 
        {
            "location": "/Interface-functions/#hello-examples", 
            "text": "See below and files  hello.erl  and  hello2.erl  in  examples/hello/ .", 
            "title": "Hello Examples"
        }, 
        {
            "location": "/Interface-functions/#functions", 
            "text": "eval  and  do  functions differ only in what they return. The  do  functions return results and a new Lua State, the  eval  functions return a tuple starting on 'ok' or 'error', then the result, or cause of error.  do --  {Result, State}\n\neval --  {ok, Result} | {error, Reason}", 
            "title": "Functions"
        }, 
        {
            "location": "/Interface-functions/#luerlevalstringbinaryform-state-ok-result-error-reason", 
            "text": "Evaluate a Lua expression passed in as a string or binary, and return its result.", 
            "title": "luerl:eval(String|Binary|Form[, State]) -&gt; {ok, Result} | {error, Reason}."
        }, 
        {
            "location": "/Interface-functions/#luerlevalfilepath-state-ok-result-error-reason", 
            "text": "Load and execute a file, and return the result.", 
            "title": "luerl:evalfile(Path[, State]) -&gt; {ok, Result} | {error, Reason}."
        }, 
        {
            "location": "/Interface-functions/#luerldostringbinaryform-state-result-newstate", 
            "text": "Evaluate a Lua expression and return its result, and the new Lua State.", 
            "title": "luerl:do(String|Binary|Form[, State]) -&gt; {Result, NewState}."
        }, 
        {
            "location": "/Interface-functions/#luerldofilepath-state-result-newstate", 
            "text": "Load and execute the Lua code in the file and return its result, and the new Lua State. Equivalent to doing luerl:do(\"return dofile('FileName')\").", 
            "title": "luerl:dofile(Path[, State]) -&gt; {Result, NewState}."
        }, 
        {
            "location": "/Interface-functions/#luerlloadstringbinary-state-okfunctionnewstate-error-reason", 
            "text": "Parse a Lua chunk as string or binary, and return a compiled chunk ('form').", 
            "title": "luerl:load(String|Binary[, State]) -&gt; {ok,Function,NewState} | {error, Reason} ."
        }, 
        {
            "location": "/Interface-functions/#luerlloadfilefilename-state-okfunctionnewstate", 
            "text": "Parse a Lua file, and return a compiled chunk ('form').", 
            "title": "luerl:loadfile(FileName[, State]) -&gt; {ok,Function,NewState}."
        }, 
        {
            "location": "/Interface-functions/#luerlpath_loadfilepath-filename-state-okfunctionfullnamestate", 
            "text": "Search Path until the file FileName is found. Parse the file and return a compiled chunk ('form'). If Path is not given then the path defined in the environment variable LUA_LOAD_PATH is used.", 
            "title": "luerl:path_loadfile([Path, ], FileName, State) -&gt; {ok,Function,FullName,State}."
        }, 
        {
            "location": "/Interface-functions/#luerlload_modulekeypath-erlangmodule-state-state", 
            "text": "Load  ErlangModule  and install its table at  KeyPath .", 
            "title": "luerl:load_module(KeyPath, ErlangModule, State) -&gt; State."
        }, 
        {
            "location": "/Interface-functions/#luerlload_module1keypath-erlangmodule-state-state", 
            "text": "Load  ErlangModule  and install its table at  KeyPath .", 
            "title": "luerl:load_module1(KeyPath, ErlangModule, State) -&gt; State."
        }, 
        {
            "location": "/Interface-functions/#luerlinit-state", 
            "text": "Get a new Lua State = a fresh Lua VM instance.", 
            "title": "luerl:init() -&gt; State."
        }, 
        {
            "location": "/Interface-functions/#luerlcallform-args-state-resultstate", 
            "text": "", 
            "title": "luerl:call(Form, Args[, State]) -&gt; {Result,State}"
        }, 
        {
            "location": "/Interface-functions/#luerlcall_chunkform-args-state-resultstate", 
            "text": "Call a compiled chunk or function. Use the call_chunk, call has been kept for backwards compatibility.", 
            "title": "luerl:call_chunk(Form, Args[, State]) -&gt; {Result,State}"
        }, 
        {
            "location": "/Interface-functions/#luerlcall_functionkeypath-args-state-resultnewstate", 
            "text": "Call a function already defined in the state.  KeyPath  is a list of names to the function.  KeyPath ,  Args  and  Result  are automatically encode/decoded.", 
            "title": "luerl:call_function(KeyPath, Args[, State]) -&gt; {Result,NewState}"
        }, 
        {
            "location": "/Interface-functions/#luerlcall_function1keypath-args-state-resultnewstate", 
            "text": "Call a function already defined in the state.  KeyPath  is a list of keys to the function.  KeyPath ,  Args  and  Result  are  NOT  encode/decoded.", 
            "title": "luerl:call_function1(KeyPath, Args, State) -&gt; {Result,NewState}"
        }, 
        {
            "location": "/Interface-functions/#luerlcall_methodmethpath-args-state-resultnewstate", 
            "text": "Call a method already defined in the state.  MethPath  is a list of names to the method.  MethPath ,  Args  and  Result  are automatically encode/decoded.", 
            "title": "luerl:call_method(MethPath, Args[, State]) -&gt; {Result,NewState}."
        }, 
        {
            "location": "/Interface-functions/#luerlcall_method1methpath-args-state-resultnewstate", 
            "text": "Call a method already defined in the state.  MethPath  is a list of keys to the method.  Keys ,  Args  and  Result  are  NOT  encode/decoded.", 
            "title": "luerl:call_method1(MethPath, Args, State) -&gt; {Result,NewState}"
        }, 
        {
            "location": "/Interface-functions/#luerlstopstate-gcedstate", 
            "text": "Garbage collects the state and (todo:) does away with it.", 
            "title": "luerl:stop(State) -&gt; GCedState."
        }, 
        {
            "location": "/Interface-functions/#luerlgcstate-state", 
            "text": "Runs the (experimental) garbage collector on a state and returns the new state.", 
            "title": "luerl:gc(State) -&gt; State."
        }, 
        {
            "location": "/Interface-functions/#luerlset_tablepath-value-state-state", 
            "text": "Sets a value inside the Lua state. Value is automatically encoded.  You can use this function to expose an function to the Lua code by\n using this interface:\n   fun(Args, State) -  {Results, State}\n Args and Results must be a list of Luerl compatible erlang values.", 
            "title": "luerl:set_table(Path, Value, State) -&gt; State."
        }, 
        {
            "location": "/Known-bugs/", 
            "text": "Some things which are known not to be implemented or work properly:\n\n\n\n\n\n\ncoroutines and goto\n\n\n\n\n\n\nonly limited standard libraries\n\n\n\n\n\n\nproper handling of _ENV\n\n\n\n\n\n\ntail-call optimization in return\n\n\n\n\n\n\nFunctions defined in a loop, \nwhile\n, \nrepeat\n and \nfor\n, \nand\n when\nthe loop is exited with a \nbreak\n from inside an \nif\n will generate an\nerror when called. For example the functions defined in\n\n\nfor i=1,10 do\n  a[i] = {set = function(x) i=x end, get = function () return i end}\n  if i == 3 then break end\nend\n\n\n\nNote:\n This only occurs if the loop is actually exited with the\nbreak, otherwise there is no problem.", 
            "title": "Known bugs"
        }, 
        {
            "location": "/Standard-library/", 
            "text": "There is also a library module, \nluerl_lib\n, which contains functions which may be used.\n\n\nluerl_lib:first_value(ReturnList) -\n Value.\n\n\nluerl_lib:is_true_value(ReturnList) -\n true | false.\n\n\nCurrent implementation functions\n\n\n\n\n_G\n\n\n_VERSION\n\n\nassert\n\n\ncollectgarbage\n\n\ndofile\n\n\neprint\n\n\nerror\n\n\ngetmetatable\n\n\nipairs\n\n\nload\n\n\nloadfile\n\n\nnext\n\n\npairs\n\n\npcall\n\n\nprint\n\n\nrawequal\n\n\nrawget\n\n\nrawlen\n\n\nrawset\n\n\nrequire\n\n\nselect\n\n\nsetmetatable\n\n\ntonumber\n\n\ntostring\n\n\ntype\n\n\nunpack\n\n\nio.flush\n\n\nio.write\n\n\nmath.abs\n\n\nmath.acos\n\n\nmath.asin\n\n\nmath.atan\n\n\nmath.atan2\n\n\nmath.ceil\n\n\nmath.cos\n\n\nmath.cosh\n\n\nmath.deg\n\n\nmath.exp\n\n\nmath.floor\n\n\nmath.fmod\n\n\nmath.frexp\n\n\nmath.huge\n\n\nmath.ldexp\n\n\nmath.log\n\n\nmath.log10\n\n\nmath.max\n\n\nmath.min\n\n\nmath.modf\n\n\nmath.pi\n\n\nmath.pow\n\n\nmath.rad\n\n\nmath.random\n\n\nmath.randomseed\n\n\nmath.sin\n\n\nmath.sinh\n\n\nmath.sqrt\n\n\nmath.tan\n\n\nmath.tanh\n\n\nos.clock\n\n\nos.date\n\n\nos.difftime\n\n\nos.getenv\n\n\nos.time\n\n\npackage.config\n\n\npackage.loaded\n\n\npackage.preload\n\n\npackage.path\n\n\npackage.searchers\n\n\npackage.searchpath\n\n\nstring.byte\n\n\nstring.char\n\n\nstring.find\n\n\nstring.format (should handle most things now)\n\n\nstring.gmatch\n\n\nstring.gsub\n\n\nstring.len\n\n\nstring.lower\n\n\nstring.match\n\n\nstring.rep\n\n\nstring.reverse\n\n\nstring.sub\n\n\nstring.upper\n\n\ntable.concat\n\n\ntable.insert\n\n\ntable.pack\n\n\ntable.remove\n\n\ntable.sort\n\n\ntable.unpack\n\n\nbit32.band\n\n\nbit32.bnot\n\n\nbit32.bor\n\n\nbit32.btest\n\n\nbit32.bxor\n\n\nbit32.lshift\n\n\nbit32.rshift\n\n\nbit32.arshift\n\n\nbit32.lrotate\n\n\nbit32.rrotate\n\n\nbit32.extract\n\n\nbit32.replace\n\n\ndebug.getmetatable\n\n\ndebug.getuservalue\n\n\ndebug.setmetatable\n\n\ndebug.setuservalue", 
            "title": "Standard library"
        }, 
        {
            "location": "/Standard-library/#luerl_libfirst_valuereturnlist-value", 
            "text": "", 
            "title": "luerl_lib:first_value(ReturnList) -&gt; Value."
        }, 
        {
            "location": "/Standard-library/#luerl_libis_true_valuereturnlist-true-false", 
            "text": "", 
            "title": "luerl_lib:is_true_value(ReturnList) -&gt; true | false."
        }, 
        {
            "location": "/Standard-library/#current-implementation-functions", 
            "text": "_G  _VERSION  assert  collectgarbage  dofile  eprint  error  getmetatable  ipairs  load  loadfile  next  pairs  pcall  print  rawequal  rawget  rawlen  rawset  require  select  setmetatable  tonumber  tostring  type  unpack  io.flush  io.write  math.abs  math.acos  math.asin  math.atan  math.atan2  math.ceil  math.cos  math.cosh  math.deg  math.exp  math.floor  math.fmod  math.frexp  math.huge  math.ldexp  math.log  math.log10  math.max  math.min  math.modf  math.pi  math.pow  math.rad  math.random  math.randomseed  math.sin  math.sinh  math.sqrt  math.tan  math.tanh  os.clock  os.date  os.difftime  os.getenv  os.time  package.config  package.loaded  package.preload  package.path  package.searchers  package.searchpath  string.byte  string.char  string.find  string.format (should handle most things now)  string.gmatch  string.gsub  string.len  string.lower  string.match  string.rep  string.reverse  string.sub  string.upper  table.concat  table.insert  table.pack  table.remove  table.sort  table.unpack  bit32.band  bit32.bnot  bit32.bor  bit32.btest  bit32.bxor  bit32.lshift  bit32.rshift  bit32.arshift  bit32.lrotate  bit32.rrotate  bit32.extract  bit32.replace  debug.getmetatable  debug.getuservalue  debug.setmetatable  debug.setuservalue", 
            "title": "Current implementation functions"
        }, 
        {
            "location": "/The-Lua-API/", 
            "text": "Lua is an embeddable language implemented as a library that offers a clear API for applications inside a register-based virtual machine.\n\n\nThis ability to be used as a library to extend an application is what makes Lua an extension language. \n\n\nAt the same time, a program that uses Lua can register new functions in the Lua environment; such functions are implemented in Erlang (or another language) and can add facilities that cannot be written directly in Lua. This is what makes Lua an extensible language.\n\n\nThese two views of Lua (as extension language and as extensible language) correspond to two kinds of interaction between Erlang and Lua. In the first kind, Erlang has the control and Lua is the library. The Erlang code in this kind of interaction is what we call application code. \n\n\nIn the second kind, Lua has the control and Erlang is the library. Here, the Erlang code is called library code. Both application code and library code use the same API to communicate with Lua, the so called Luerl API.\n\n\nModules, Object Oriented programming and iterators need no extra features in the Lua API. They are all done with standard mechanisms for tables and first-class functions with lexical scope.\n\n\nException handling and code load go the opposite way: primitives in the API are exported to Lua from the base system C, JIT, BEAM.\n\n\nLua implementations are based on the idea of closures, a closure represents the code of a function plus the environment where the function was defined.\n\n\nLike with tables, Lua itself uses functions for several important constructs in the language.\n\n\nThe use of constructors based on functions helps to make the API simple and general.\n\n\nThere are no coroutines in Luerl it may seems counter intuitive coming from a more common Lua background.\n\n\nIn this ecosystem you always want to use processes instead, the BEAM Virtual Machine it's build for handling independent isolated processes that are very small and almost free at creation time and context switching. The main difference between processes and coroutines is that, in a multiprocessor machine a OTP release on the BEAM Virtual Machine runs several processes concurrently in parallel.\n\n\nCoroutines, on the other hand, runs only one at the time on a single core and this running coroutine only suspends its execution when it explicitly requests to be suspended.", 
            "title": "The Lua API"
        }, 
        {
            "location": "/VM-&-compiler/", 
            "text": "The Lua VM is a hybrid implementation. It uses normal Erlang function calls for Luerl\ncalls and blocks and has a small instruction set for operations inside\na block. This is a pure stack machine.\n\n\nBlocks keep variables in tuples. There are two variable types\ndepending on how they are defined:\n\n\n\n\n\n\nLocal variables that are used in this block and sub-blocks, but not\n  used in any functions defined in the blocks. These are kept in a\n  stack of tuples, the LocalVars or Lvs, and referenced by offset in stack\n  and offset in tuple.\n\n\n\n\n\n\nEnvironment variables that are defined in functions which are\n  defined in this block or in sub-blocks. This mean they must be kept\n  around as long as the functions are alive and are stored in the\n  global heap as each invocation can modify them. They are kept in a\n  stack of references, the EnvironmentVars or Evs, to tuples in the\n  global heap and referenced by offset in stack and offset in tuple.\n\n\n\n\n\n\nA function contains a reference to the stack of environment variables\nwhich existed when it was created. Note that the mutable nature of Lua\ndata means that these can be modified and the changes must be visible\nto every function which references them.\n\n\nThere is also a stack containing arguments and temporary values. This\nis stack is \"global\" in the sense that it is passed through all calls\nand blocks. It is also passed as an argument into functions\nimplemented in Erlang. This is so that event of a Lua/Luerl GC the\ncollector uses the stack to determine which data in the global heap is\nto be saved.\n\n\nTo handle multiple return values we always return a list of values.\nThe only place this is not done is in luerl_eval.erl when getting\nvalues from the environment where we can only have one value. This\nmeans a lot of calls to first_value/1 in luerl_emul.erl, but the\nconsistency is worth it.\n\n\nSimilarily all the arguments in a function call are passed in a list.\nThe function then unpacks the list into its arguments, including\n'...'.\n\n\nAll of the predefined libraries have an install/1 function. This is\ncalled when initialising Luerl; it does any library specific\ninitialisation necessary and returns a table containing the functions\nin the library.\n\n\nWe create a unique tag which is saved in the environment. This is used\nso we can implement 'break' with a simple throw. The thrown value\nincludes the tag so we can uniquely catch it and not get confused with\na throw/error/exit from the erlang code.\n\n\nGarbage collector\n\n\nIs important to note that the garbage collector is never called by \nluerl\n itself. \n\n\nThe main reason is that we could not work out a decent heuristic about when to call it. For example there is no heap as such we can check to see how much \nluerl\n memory we are using and when it fills. So it is left up to the caller to do so. Currently calling it from inside \nluerl\n is a not an option so you need to call it from the Erlang level.\n\n\nThis might be useful if you want to reuse the initial state for each call as you can just throw away the returned state and not waste time doing garbage collection.\n\n\nCompiler\n\n\nThe compiler has state at different levels:\n\n\n\n\nIn luerl_comp there is #comp{} containing code, options and errors.\n\n\nIn the #cst{} between the compiler modules for data outside the\n  code. This empty so far.\n\n\nInside and local to the compiler modules.\n\n\n\n\nAll the compiler modules are written so that they chain a status\nargument through their code, even if it not used. When they are not\nused we just send the atom 'nil' through and check it comes out \"the\nother end\".", 
            "title": "VM & compiler"
        }, 
        {
            "location": "/VM-&-compiler/#garbage-collector", 
            "text": "Is important to note that the garbage collector is never called by  luerl  itself.   The main reason is that we could not work out a decent heuristic about when to call it. For example there is no heap as such we can check to see how much  luerl  memory we are using and when it fills. So it is left up to the caller to do so. Currently calling it from inside  luerl  is a not an option so you need to call it from the Erlang level.  This might be useful if you want to reuse the initial state for each call as you can just throw away the returned state and not waste time doing garbage collection.", 
            "title": "Garbage collector"
        }, 
        {
            "location": "/VM-&-compiler/#compiler", 
            "text": "The compiler has state at different levels:   In luerl_comp there is #comp{} containing code, options and errors.  In the #cst{} between the compiler modules for data outside the\n  code. This empty so far.  Inside and local to the compiler modules.   All the compiler modules are written so that they chain a status\nargument through their code, even if it not used. When they are not\nused we just send the atom 'nil' through and check it comes out \"the\nother end\".", 
            "title": "Compiler"
        }, 
        {
            "location": "/When-to-use-Luerl/", 
            "text": "Fast Language Switch:\n Luerl should allow you to switch between Erlang and\nLua incredibly fast, introducing a way to use very small bits of logic\nprogrammed in Lua, inside an Erlang application, with good performance.\n\n\nMulticore:\n Luerl provides a way to transparently utilize multicores. The\nunderlying Erlang VM takes care of the distribution.\n\n\nMicroprocesses:\n It should give you a Lua environment that allows you to\neffortlessly run tens of thousands of Lua processes in parallel, leveraging the\nfamed microprocesses implementation of the Erlang VM. The empty Luerl\nState footprint will be yet smaller than the C Lua State footprint.\n\n\nForking Up:\n Because of the immutable nature of the Luerl VM, it becomes\na natural operation to use the same Lua State as a starting point for multiple\nparallel calculations.\n\n\nHowever, Luerl will generally run slower than a reasonable native Lua\nimplementation. This is mainly due the emulation of mutable data on top of an\nimmutable world. There is really no way around this. An alternative would be\nto implement a special Lua memory outside of the normal Erlang, but this would\ndefeat the purpose of Luerl. It would instead be then more logical to connect to\na native Lua.\n\n\nSome valid use cases for Luerl are:\n\n\n\n\n\n\nLua code will be run only occasionally and it wouldn't be worth\n  managing an extra language implementation in the application.\n\n\n\n\n\n\nThe Lua code chunks are small so the slower speed is weighed up by\n  Luerl's faster interface.\n\n\n\n\n\n\nThe Lua code calculates and reads variables more than changing them.\n\n\n\n\n\n\nThe same Lua State is repeatedly used to 'fork up' as a basis for\n  massively many parallel calculations, based on the same state.\n\n\n\n\n\n\nIt is easy to run multiple instances of Luerl which could better\n  utilise multicores.\n\n\n\n\n\n\nThere may be others.", 
            "title": "When to use Luerl"
        }
    ]
}